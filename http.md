
### http常见的错误码
+ 1xx表示消息
+ 2xx表示成功
+ 3xx表示重定向(302,303,304)
+ 4xx表示请求错误(400,401, 403, 404, 405)
+ 5xx表示服务端错误(500, 501)

1. 200 表示成功
2. 301 永久性定向，资源已经被分配了新的url
3. 302 临时性重定向，资源已经被临时分配了新的url 
4. 303 表示资源存在着另外一个url，应该使用get方法定向获取资源
5. 304 服务器允许访问资源，但是发生了请求未满足的情况
6. 307 同302
7. 400 请求报文存在语法错误
8. 403 对请求资源的访问被服务器拒绝
9. 404 服务器上没有找到请求的资源
10. 500 服务端在请求时发生了错误
11. 501 请求超出服务器范围，如服务器不支持某个方法
12. 503 服务器暂时处于超负荷或停机状态，无法处理请求
13. 505 服务器不支持或拒绝支持在请求中使用的http版本

### 302 303 307
+ 302是1.0
+ 1.1中细化增加了303 307
+ 303表示客户端需要使用get方法，会把post请求变成get请求重定向
+ 307不会

### htpp1.0和1.1有什么区别
+ 1.0有三种请求方法 get,post,head
+ 1.1新增5种： options, put, delete, trace, connect

### http2 比 1有什么优势
+ 二进制分帧  
   帧：http2通信最小单位   
  一个消息由一个或多个帧组成
+ http2采用二进制传输数据，1.x则采用文本格式，二进制格式解析更高效
+ 多路复用

### 网络协议分层
+ 物理层
+ 连接层
+ 网络层
+ 传输层
+ 应用层

### 物理层 Physical layer
光纤、电缆、电磁波等真实存在的物理媒介。针对某种媒介，电脑有相应的接口，用来接收物理信号，并解读成0/1序列

### 连接层 Link layer
连接层中，信息以帧(frame)为单位传输。  
帧：一段有限的0/1序列。  
传输层的功能是识别0/1序列中包含的帧。比如：根据一定的0/1组合识别出帧的起始和终止。  
在帧中，有收信地址(Resource, RSC)和收信地址(Destnation, DST),还有能探测错误的校验序列(Frame Check Sequence)  
帧中最重要的是传输数据(payload), 这些数据往往符合更高层协议，供网络的上层使用。  
与数据配套，帧中也有数据的类型(Type)信息。  
连接层不关心数据中到底包含了什么，帧就像一个信封，把数据包裹起来  

以太网(Ehernet)和WIFI是现在最常见的连接层协议。  
通过连接层协议，我们可以建立局域的以太网或WIFI局域网，并让处于同一个局域网内的两台计算机通信。  
连接层就像一个社区邮差，他认识社区中的每一户人。社区中的人都可以将信(帧)交给他，他负责将信送到同一社区的另一户人家。

### 网络层 Network layer
路由器(router)功能：
1. 能从物理层在两个网络的接收和发送0/1序列
2. 能同时理解两种网络的帧格式  
一个路由器有多个网卡(NIC, Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。  
在帧经过路由到达另一个网络时，路由会读取帧的信息，并改写以发送到另一个网络。  
所以路由器就像是在两个社区都有分支的邮局，a社区的邮差将信送到a社区的邮局。信封上的地址是a社区的邮局，信封中信纸上写的地址是ip地址。邮局会通过在b社区的分支将信转交到b社区的邮差手里，并由b社区的邮差送到人家手里。  
每个邮局一般连接多个社区，一个社区也有多个邮局，分别通往不同的社区。有时候一封信要经过多个邮局转交，才最终到达目的地，这个过程叫route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网


### 传输层 Transport layer
物理层、连接层和网络层能让不同的计算机通信。但计算机有很多进程，每个进程都有通信需求。  
传输层就是在信纸的空白处写上收信人信息。每所房子都会配置一个管理员(传输层协议)，管理员从邮差手中拿到信，会根据收信人信息，将信给房中的收信人。  
传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们会写上目的地端口号。当信到达管理员手中时，他会根据传输层协议，识别端口号，将信送给不同的人。  
TCP和UDP是两种不同的传输协议。  
+ UDP协议类似信件交流过程
+ TCP协议像情人间的私语，连续不断，一方发送多条信息，而另一方必须将这些信息按顺序排列起来才能明白全部意思。  
    TCP还有控制网络交通等功能

### 应用层 Application layer 
通过物理层、连接层、网络层、传输层可以实现任意两个人之间的通信。但是人与人之间的通信会存在一些术语和规则。  
应用层协议是对信件内容进一步的用语规范。  
应用层的协议包括用于web浏览器的http协议，用于传输文件的ftp协议，用于email的imap协议等等。  

***

写信人必须按照各层的协议，封装好整个信封(encapsulation)；  
收信人则按照相反的顺序来拆开这个信封。整个过程是： 可读信息 -> 二进制 -> 可读信息。  
计算机只能理解和传输0/1序列，而计算机的用户则总是输入和输出可读信息。网络协议保证了可读信息在转换和传输过程中的完整性。  

### TCP
Transmission Control protocol 传输控制协议  
是一种面向连接的、可靠的、基于字节流的传输层通信协议。    

### UDP
User Dataprogram Protocol 用户数据包协议  
UDP为应用程序提供一种无需建立连接就可以发送封装的IP数据包方法  
UDP除了给应用程序发送数据包功能并允许他们在所需的层次上架构自己的协议之外，不做其他事情  
UDP报文发送之后，无法得知是否安全完整到达。  
UDP用来支持需要在计算机之间传输数据的网络应用，包括网络视频会议、多媒体应用、音频等

### 浏览器输入一个地址，到页面展示 中间经历了哪些东西
1. 浏览器输入url，先解析url是否合法
2. 浏览器检查是否缓存，如果有就直接展示，没有就下一步
3. 检查本地域名服务器是否有对应的ip地址，如果有则返回相应的ip地址，没有则请求dns服务器，获取ip地址。拿到ip地址之后发送请求
4. 传输层tcp传输报文，TCP协议通过“三次握手”等方法保证传输的安全可靠
5. 网络层ip协议查询mac地址
6. 找到mac地址之后，将数据发送到数据链路层传输，客户端发送请求结束
7. 服务器收到客户端发送的请求后，查找客户端的请求资源，返回响应报文
8. 请求成功后，服务器会返回相应的html文件
9. 开始渲染：解析html以构建dom树
10. 构建渲染树
11. 布局渲染树
12. 绘制渲染树


### cookie和session机制
+ cookie保存在客户端，session保存在服务端
+ cookie可以减轻服务器压力，但是不安全，容易进行cookie欺骗
+ session安全一点，但是有服务器压力

### crsf
跨站请求伪造：攻击者盗用了用户身份，以用户的名义发送恶意请求  
过程：  
1. 用户用浏览器打开了网站A，输入账密登录A
2. 验证用户信息后，A产生的cookie信息返回给浏览器并保存到了本地
3. 用户退出A，在同一个浏览器中打开了网站B
4. 网站B收到用户请求后返回一些攻击性的代码，并发出一个请求访问网站A
5. 浏览器在接收到这些攻击代码后，在用户不知情的情况下携带cookie信息，向网站A发出请求，A不知道请求是用B发起，会根据用户的cookie信息以用户的权限处理该请求，这些攻击代码会被执行
  
防御方法：  
表单提交中增加hash值，服务端进行hash验证  
图片随机字符验证  
使用token，服务端给用户生成一个token，加密后传递给用户，用户提交时需要携带这个token


### xss 跨站脚本漏洞
攻击者往web页面中插入恶意的script代码，当用户访问页面时，嵌入其中的script代码会被执行，攻击用户  
xss分类
+ 反射型：
+ 存储型：在个人信息或者发表文章等地方，这些代码会被存储到服务器中

+ script标签中插入
+ img标签的 onerror事件
+ a标签onmousemove, onmouseover事件
+ click事件

防御：
+ 特殊字符转换
+ 对敏感的cookie设置http-only限制，让js获取不到cookie内容  
response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly")

### 浏览器缓存原理
分为强缓存和协商缓存  
1. 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，如果命中强缓存，浏览器直接从自己的缓存中读取资源，不会发送请求到服务。
2. 当强缓存没有命中时，浏览器会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果命中协商缓存，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉浏览器直接从缓存中加载这个资源，于是浏览器又会从缓存中加载这个资源

共同点： 如果命中，都会从缓存中加载资源，不从服务器加载资源数据；  
区别：强缓存不会发送请求，协商缓存会发送请求  
两者都没有命中时，浏览器直接从服务器加载资源数据  

### 浏览器缓存资源存储
+ memory cache 匹配优先级高；存储一些派生类的资源文件，退出进程时数据会被清除，一般存储：脚本、字体、图片
+ disk cache 匹配优先级低；存储一些派生类的资源文件，退出进程时数据不会被清除，需要进行I/O操作，容量大；一般存储非脚本文件：css等

### 强缓存
浏览器在加载资源时，会先根据本地缓存资源的header中的 expires 和 cache-control 判断是否命中强缓存
+ Expires：http1.0时的规范。它的值是一个绝对时间的GMT格式的字符串，这个时间代表这个资源的失效时间。  
缺陷：由于是一个绝对时间，如果客户端与服务器的时间偏差较大，会导致缓存混乱

+ Cache-control: http1.1的规范。主要利用该字段的max-age值判断，是一个相对时间  
cache-control: max-age=3600 代表着资源的有效期为3600秒  
cache-control比较常用的设置值：   
no-cache: 需要进行协商缓存，发送请求到服务器确认是否使用缓存  
no-store: 禁止使用缓存,每一次都要重新请求数据  
public: 可以被所有的用户缓存，包括终端用户和cdn等中间代理服务器  
must-revalidate: 如果缓存内容失效，必须去服务器进行重新校验

+ cache-control和expires可以在服务端配置同时启用，同时启用时cache-control优先级高

### 协商缓存
强缓存没有命中时，浏览器会发送一个请求到服务器，服务器会根据header中的部分信息来判断是否命中缓存。如果命中，返回304，告诉浏览器资源未更新，可使用本地缓存  
header中的信息指：last-Modified/If-Modify-Since 和 ETag/If-None-Match
+ Last-Modify/If-Modify-Since  
浏览器第一次请求一个资源的时候，服务器返回的header会加上Last-Modify（标识该资源的最后修改时间）  
当浏览器再次请求该请求时，request header中会包含If-Modify-Since，该值为缓存之前的Last-Modify。服务器收到If-Modify-Since后，会根据资源的最后修改时间判断是否命中缓存  
如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回last-Modified  
缺点：  
短时间资源发生了变化，last-Modified不会发生变化

+ ETag/If-None-Match  
返回一个校验码，ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器会根据浏览器上发送的if-None-Match值来判断是否命中缓存  
当服务器返回304 Not modified的响应时，由于ETag重新生成过了，response header中还会把这个ETag返回，即使没有变化  

ETag可以和Last-Modified一起使用，服务器会优先验证ETag，如果一致 才会对比Last-Modified，最后才决定是否返回304

### https加密原理
+ 为什么要加密：http的内容是明文传输，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点。如果信息在传输过程中被劫持，传输的内容就会完全暴露，劫持者还可以篡改传输的信息不被察觉，这就是“中间人攻击”。
+ 对称加密：使用密钥加密信息，再使用秘钥对信息解密
+ 非对称加密：有两把钥匙，公钥、私钥。用公钥加密的内容必须用私钥才能解开；私钥加密的内容只能公钥打开
+ http使用的方案：对称加密 + 非对称加密  

### oAuth
开放授权，是一个开放标准，允许用户让第三方应用(网站/app)访问该用户在另一个网站(qq,weibo)上存储的私密信息(照片、视频、联系人)，而无需将用户名和密码提供给第三方

### 服务端如何开启gzip
content-Encoding: gzip  
node: 使用compression  
webpack： compression-webpack-plugin


