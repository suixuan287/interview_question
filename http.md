
### http常见的错误码
+ 1xx表示消息
+ 2xx表示成功
+ 3xx表示重定向(302,303,304)
+ 4xx表示请求错误(400,401, 403, 404, 405)
+ 5xx表示服务端错误(500, 501)

1. 200 表示成功
2. 301 永久性定向，资源已经被分配了新的url
3. 302 临时性重定向，资源已经被临时分配了新的url 
4. 303 表示资源存在着另外一个url，应该使用get方法定向获取资源
5. 304 服务器允许访问资源，但是发生了请求未满足的情况
6. 307 同302
7. 400 请求报文存在语法错误
8. 403 对请求资源的访问被服务器拒绝
9. 404 服务器上没有找到请求的资源
10. 500 服务端在请求时发生了错误
11. 501 请求超出服务器范围，如服务器不支持某个方法
12. 503 服务器暂时处于超负荷或停机状态，无法处理请求
13. 505 服务器不支持或拒绝支持在请求中使用的http版本

### 302 303 307
+ 302是1.0
+ 1.1中细化增加了303 307
+ 303表示客户端需要使用get方法，会把post请求变成get请求重定向
+ 307不会

### htpp1.0和1.1有什么区别
+ 1.0有三种请求方法 get,post,head
+ 1.1新增5种： options, put, delete, trace, connect

### http2 比 1有什么优势
+ 二进制分帧  
   帧：http2通信最小单位   
  一个消息由一个或多个帧组成
+ http2采用二进制传输数据，1.x则采用文本格式，二进制格式解析更高效

### 浏览器输入一个地址，到页面展示 中间经历了哪些东西
1. 浏览器输入url，先解析url是否合法
2. 浏览器检查是否缓存，如果有就直接展示，没有就下一步
3. 检查本地域名服务器是否有对应的ip地址，如果有则返回相应的ip地址，没有则请求dns服务器，获取ip地址。拿到ip地址之后发送请求
4. 传输层tcp传输报文，TCP协议通过“三次握手”等方法保证传输的安全可靠
5. 网络层ip协议查询mac地址
6. 找到mac地址之后，将数据发送到数据链路层传输，客户端发送请求结束
7. 服务器收到客户端发送的请求后，查找客户端的请求资源，返回响应报文
8. 请求成功后，服务器会返回相应的html文件
9. 开始渲染：解析html以构建dom树
10. 构建渲染树
11. 布局渲染树
12. 绘制渲染树

### cookie和session机制
+ cookie保存在客户端，session保存在服务端
+ cookie可以减轻服务器压力，但是不安全，容易进行cookie欺骗
+ session安全一点，但是有服务器压力

### csrf
跨站请求伪造：攻击者盗用了用户身份，以用户的名义发送恶意请求  
过程：  
1. 用户用浏览器打开了网站A，输入账密登录A
2. 验证用户信息后，A产生的cookie信息返回给浏览器并保存到了本地
3. 用户退出A，在同一个浏览器中打开了网站B
4. 网站B收到用户请求后返回一些攻击性的代码，并发出一个请求访问网站A
5. 浏览器在接收到这些攻击代码后，在用户不知情的情况下携带cookie信息，向网站A发出请求，A不知道请求是用B发起，会根据用户的cookie信息以用户的权限处理该请求，这些攻击代码会被执行
  
防御方法：  
表单提交中增加hash值，服务端进行hash验证  
图片随机字符验证  
使用token，服务端给用户生成一个token，加密后传递给用户，用户提交时需要携带这个token


### xss 跨站脚本漏洞
攻击者往web页面中插入恶意的script代码，当用户访问页面时，嵌入其中的script代码会被执行，攻击用户  
xss分类
+ 反射型：
+ 存储型：在个人信息或者发表文章等地方，这些代码会被存储到服务器中

+ script标签中插入
+ img标签的 onerror事件
+ a标签onmousemove, onmouseover事件
+ click事件

防御：
+ 特殊字符转换
+ 对敏感的cookie设置http-only限制，让js获取不到cookie内容  
response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly")

### 浏览器缓存原理
分为强缓存和协商缓存  
1. 浏览器在加载资源时，先根据中国资源的一些http header判断它是否命中强缓存，如果命中强缓存，浏览器直接从自己的缓存中读取资源，不会发送请求到服务。
2. 当强缓存没有命中时，浏览器会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果命中协商缓存，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉浏览器直接从缓存中加载这个资源，于是浏览器又会从缓存中加载这个资源

共同点： 如果命中，都会从缓存中加载资源，不从服务器加载资源数据；  
区别：强缓存不会发送请求，协商缓存会发送请求  
两者都没有命中时，浏览器直接从服务器加载资源数据  

### 浏览器缓存资源存储
+ memory cache 匹配优先级高；存储一些派生类的资源文件，退出进程时数据会被清除，一般存储：脚本、字体、图片
+ disk cache 匹配优先级低；存储一些派生类的资源文件，退出进程时数据不会被清除，需要进行I/O操作，容量大；一般存储非脚本文件：css等

### 强缓存
浏览器在加载资源时，会先根据本地缓存资源的header中的 expires 和 cache-control 判断是否命中强缓存
+ Expires：http1.0时的规范。它的值是一个绝对时间的GMT格式的字符串，这个时间代表这个资源的失效时间。  
缺陷：由于是一个绝对时间，如果客户端与服务器的时间偏差较大，会导致缓存混乱

+ Cache-control: http1.1的规范。主要利用该字段的max-age值判断，是一个相对时间  
cache-control: max-age=3600 代表着资源的有效期为3600秒  
cache-control比较常用的设置值：   
no-cache: 需要进行协商缓存，发送请求到服务器确认是否使用缓存  
no-store: 禁止使用缓存,每一次都要重新请求数据  
public: 可以被所有的用户缓存，包括终端用户和cdn等中间代理服务器  
must-revalidate: 如果缓存内容失效，必须去服务器进行重新校验

+ cache-control和expires可以在服务端配置同时启用，同时启用时cache-control优先级高

### 协商缓存
强缓存没有命中时，浏览器会发送一个请求到服务器，服务器会根据header中的部分信息来判断是否命中缓存。如果命中，返回304，告诉浏览器资源未更新，可使用本地缓存  
header中的信息指：last-Modified/If-Modify-Since 和 ETag/If-None-Match
+ Last-Modify/If-Modify-Since  
浏览器第一次请求一个资源的时候，服务器返回的header会加上Last-Modify（标识该资源的最后修改时间）  
当浏览器再次请求该请求时，request header中会包含If-Modify-Since，该值为缓存之前的Last-Modify。服务器收到If-Modify-Since后，会根据资源的最后修改时间判断是否命中缓存  
如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回last-Modified  
缺点：  
短时间资源发生了变化，last-Modified不会发生变化

+ ETag/If-None-Match  
返回一个校验码，ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器会根据浏览器上发送的if-None-Match值来判断是否命中缓存  
当服务器返回304 Not modified的响应时，由于ETag重新生成过了，response header中还会把这个ETag返回，即使没有变化  

ETag可以和Last-Modified一起使用，服务器会优先验证ETag，如果一致 才会对比Last-Modified，最后才决定是否返回304




